---
layout: post
title: "並列プログラミング：APIと難点"
category: issue-2
original:
  title: "Concurrent Programming: APIs and Challenges"
  url: http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html
  author: "Florian Kugler"
translator:
  name: "@gonsee"
  url: https://twitter.com/gonsee
---
{% include JB/setup %}

## 並列プログラミングの難点

並列プログラムを書こうとすると数多くの落とし穴が待っています。一番基本的なことから一歩踏み出そうとしたとたん、並列に実行される複数タスクの相互作用の中で起こりうる全ての状態を監視することが難しくなります。問題は非決定的に起こる可能性があり、デバッグをさらに難しくします。

並列プログラムの予測できない振る舞いを示す有名な例があります。1995年、NASAは火星にパスファインダーを送りました。お隣の赤い惑星への着陸成功からほどなくして、ミッションは[突然の終わりを迎えそうになりました](http://research.microsoft.com/en-us/um/people/mbj/Mars_Pathfinder/Mars_Pathfinder.html)。探査機が原因不明の再起動を続けたのです。優先順位の低いスレッドが優先順位の高いスレッドをブロックする「優先順位逆転」という現象でした。この問題については後ほど詳しく見ていきますが、この例から、たとえ膨大なリソースと有能なエンジニアがそろっている状況であっても、並行プログラミングが様々な形で牙を剥くことがあることがわかるでしょう。

### リソースの共有

多くの並行プログラミングに関する悪の根源は、複数スレッド間で共有されるリソースへのアクセスにあります。リソースにはプロパティやオブジェクト、より一般的にメモリ、ネットワークデバイス、ファイルなどがあります。複数スレッド間で共有するものは全てコンフリクトの原因になり得るため、このようなコンフリクトを防ぐための安全策を講じる必要があります。

問題をデモするために、カウンターとして使う整数型のプロパティというシンプルなリソースの例を見ていきましょう。並列に実行されるスレッドAとBがあり、両者が同時にカウンターをインクリメントするという状況を考えます。問題は、CやObjective-Cで書かれた１行のコードがたいていCPUへの命令としては１つではないことにあります。カウンターをインクリメントするためには、まず現在の値をメモリーから読み出し、その後値に1を加え、最後にメモリーに書き戻す必要があります。

両方のスレッドが同時にこれをやろうとしたときに生じうる危険を想像してください。例えば、スレッドAとスレッドBの両方がカウンターの値——ここでは17としましょう——をメモリに読み出し、スレッドAがカウンターを1増やして18をメモリに書き込んだとします。同時にスレッドBもカウンターを1増やして、スレッドAのすぐ後に18をメモリーに書き込んだとします。この時点でデータは壊れてしまいます。17から2回カウンターを増やしているのに値は18になってしまっているからです。

![競合状態](http://www.objc.io/images/issue-2/race-condition@2x.png)

この問題は[競合状態](http://ja.wikipedia.org/wiki/競合状態)と呼ばれ、あるスレッドがリソースへアクセスする前に他のスレッドがリソースを使っていないか確認することなしに、複数スレッドでリソースを共有すると必ず発生します。単純な整数型ではなくより複雑な構造体を扱っている場合、メモリに書き込み中に他のスレッドが読みにきて、一部は新しくて、一部は古い、または初期化されていないデータになっているというようなことも起こりえます。これを防ぐためには、複数のスレッドは共有リソースに対し相互排他的にアクセスする必要があります。

実際には状況はさらに複雑です。なぜなら最近のCPUは最適化のためにメモリへの読み込み、書き込みの順序を変えるからです。（[out-of-oder execution](http://ja.wikipedia.org/wiki/アウト・オブ・オーダー実行)）

### 相互排他

相互排他的アクセスとは特定のリソースに対して同時にアクセスできるスレッドが１つだけという意味です。これを保証するために、リソースを利用したいスレッドはまずmutex lockを獲得する必要があります。作業が完了したらロックを解放し、他のスレッドがアクセスできるようにします。

![](http://www.objc.io/images/issue-2/locking@2x.png)

相互排他アクセスを保証するのに加え、ロックはout-of-order executionに起因する問題についても対処する必要があります。CPUがプログラムの命令通りの順序でメモリへのアクセスを行うことが保証できない場合、相互排他アクセスだけでは不十分です。このCPU最適化の副作用のワークアラウンドとして[メモリバリア](http://en.wikipedia.org/wiki/Memory_barrier)が使われます。メモリバリアを使うと、バリアを超えてout-of-order executionが起こらないことを保証できます。

もちろんmutex lockの実装そのものも競合状態が起きないようにする必要があります。これは簡単な仕事ではなく、モダンなCPUに対する特別な命令を利用する必要があります。atomic operationについてはDanielの[low-level concurrency techniques](http://www.objc.io/issue-2/low-level-concurrency-apis.html)の記事が詳しいです。

Objective-Cのプロパティはatomicとして宣言することで、言語レベルのロックの仕組みが利用できます。実際プロパティはデフォルトでatomicになります。atomicとしてプロパティを宣言すると、プロパティにアクセスするたびにロックとロック解除が走ることになります。念のため全てのプロパティをatomicとして宣言しておきたくなるかもしれません。しかしロックにはコストが付いてきます。

リソースに対するロックの獲得には常にパフォーマンス上のコストがあります。ロックの獲得、解放はrace-condition freeである必要がありますが、マルチコアなシステムでこれは簡単ではありません。そしてロックを獲得するとき、スレッドは他のスレッドがロックを解放するのを待たなければならないかもしれません。この場合スレッドはスリープし、他のスレッドのロック解放の通知を受け取る必要があります。これらの作業はすべてコストが高く複雑です。

ロックにはいくつか種類があります。あるものは競合がない場合は非常に高速だが競合があると遅いというもので、またあるものは基本は高コストですが競合時のコストが比較的低いといった感じです。（ロックの競合とは既にロックされているものをさらに別のスレッドがロックしようとする状況のことです。）

ここにはトレードオフがあります。ロックの獲得と解放にはロックのオーバーヘッドと言うコストがかかります。従って[クリティカルセクション](http://ja.wikipedia.org/wiki/クリティカルセクション)に出たり入ったりを繰り返さないように気をつける必要があります。同時に、コードの中であまりにも多くの箇所でロック獲得を行うと、ロック獲得を待つためにスレッドの実行が止まるという、ロック競合のリスクがあります。これは解決が難しい問題です。

並行に実行させるつもりが、共有リソースのロックの仕方のせいで、実際には一度に１つのスレッドしかアクティブにならないようなコードを見かけることがよくあります。自分の書いたコードがマルチコア環境でどのようにスケジュールされるかを予測することはたいてい難しいです。Instrumentsの[CPU strategy view](http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html)を利用してCPUコアを効率よく利用しているかどうかを見ることができます。

### デッドロック

mutex lockは競合状態を解決しますが、残念ながら同時にもうひとつの問題（[いくつかある中のひとつ](http://en.wikipedia.org/wiki/Lock_%28computer_science%29#The_problems_with_locks)）を生み出します。デッドロックです。デッドロックは複数のスレッドが互いの終了を待って止まってしまうことで発生します。

![デッドロック](http://www.objc.io/images/issue-2/dead-lock@2x.png)

以下のコードの例を見てみましょう。これは２つの値を入れ替えるものです。

```objc
void swap(A, B)
{
    lock(lockA);
    lock(lockB);
    int a = A;
    int b = B;
    A = b;
    B = a;
    unlock(lockB);
    unlock(lockA);
}
```

これはたいていの場合うまくいきます。しかしたまたま２つのスレッドが同時に、逆の値の組で読んだ場合、

```objc
swap(X, Y); // thread 1
swap(Y, X); // thread 2
```

デッドロックが発生します。スレッド１がXに対するロックを獲得し、スレッド２がYに対するロックを獲得します。ここで両スレッドはお互いのlockを待つ状態になりますが、ロックを獲得することはありません。

スレッド間で共有されるリソースが多いほど、ロックの回数が多いほど、デッドロックに陥るリスクが高くなります。これができるだけコードをシンプルに保ち、できるだけ共有するリソースを少なくすべきもうひとつの理由です。[低レベルの並列APIの記事](http://www.objc.io/issue-2/low-level-concurrency-apis.html)の、[非同期処理についてのセクション](http://www.objc.io/issue-2/low-level-concurrency-apis.html#async)も読んでみてください。

### スターベーション（飢餓）

もう十分考えるべき問題は洗い出せたと思ったそのとき、新たな問題が現れます。共有リソースをロックすることは[readers-writers problem](http://en.wikipedia.org/wiki/Readers-writers_problem)を引き起こす可能性があります。多くの場合、読み込みのアクセスを同時に１つだけに制限することは無駄になります。そのため、読み込み時のロックは、そのリソースに対して書き込みロックがひとつもない場合のみ許可されています。この状況では、書き込みロックの獲得を待っているスレッドは、その間に発生するより多くの読み込みロックによってstarvedにさます。

この問題を解決するにはシンプルな読み込み／書き込みロックではなく、writes preferenceを与えたり、read-copy-upadteアルゴリズムを使うといった、より高度な解決策が必要です。Danielがlow-level concurrency tequniquesという記事の中で、複数のリーダー／ひとつのライターのパターンのGCDを使った実装方法について書いています。

### 優先順位逆転

このセクションはNASAの火星探査機パスファインダーが並列プログラムの問題に直面した例から始まりました。今からなぜパスファインダーが失敗しそうになったのか、そして、なぜあなたのアプリケーションが優先順位逆転という同じ問題に直面しうるのかを、詳しく見ていきましょう。

優先順位逆転とは、優先順位の低いタスクが高いタスクの実行をブロックすることで、事実上タスクの優先順位が逆転してしまう状況のことをいいます。GCDが優先順位の異なるバックグラウンドキューを利用可能にしている（I/O  throttled なものさえ含む）ので、この可能性について知っておくと良いでしょう。

この問題は、優先順位の高いタスクと低いタスクが同じリソースを共有しているときに発生し得ます。優先順位の低いタスクが共有リソースをロックするとき、優先順位の高いタスクの実行に遅延がないように、できる限り素早く完了しなければなりません。優先順位の低いタスクがロックを保有している限り、優先順位の高いタスクの実行がブロックされるため、優先順位が中のタスクが優先順位低のタスクに先行して実行されるチャンスがあります。なぜならこのとき優先順位中のタスクが実行可能なタスクの中で最も優先度が高くなっているからです。このとき優先土中のタスクが、優先度低のタスクがロックを手放すのを妨げることにより、実質的に優先度高のタスクよりも優先されることになります。

![優先順位逆転](http://www.objc.io/images/issue-2/priority-inversion@2x.pnga)

あなた自身のコードでは火星探査機で起こった再起動のようなドラマチックなことは起こらないかもしれません。優先順位逆転はもっと目立たない形で頻繁に発生します。

一般的に、異なる優先度を使ってはいけません。多くの場合、優先度高のコードが優先度低のコードが終わるのを待つことになります。GCDを利用する場合、常にdefault priority queue（直接、またはターゲットキューとして）を使いましょう。もしあなたが異なる優先度を使っているとしたら、実際によくないことが起こる可能性が高いです。

このことから導かれる教訓は、優先度の異なる複数のキューを使うことは理論上よいものに見えますが、実際は並行プログラムにさらなる複雑性と予測不能性を加えてしまうということです。そしてもしあなたが、優先度の高いタスクが原因もわからず止まってしまう奇妙な問題に直面したら、多分この記事と優先順位逆転という問題のことを思い出すでしょう。NASAのエンジニアさえ直面したこの問題を。

### まとめ

どんなにAPIがわかりやすいものに見えても、並行プログラミングとそれに関する問題がいかに複雑かが伝わったでしょうか。
