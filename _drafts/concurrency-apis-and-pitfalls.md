---
layout: post
title: "並列プログラミング：APIと難点"
category: issue-2
original:
  title: "Concurrent Programming: APIs and Challenges"
  url: http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html
  author: "Florian Kugler"
translator:
  name: "@gonsee"
  url: https://twitter.com/gonsee
---
{% include JB/setup %}

## 並列プログラミングの難点

並列プログラムを書こうとすると数多くの落とし穴が待っています。一番基本的なことから一歩踏み出そうとしたとたん、並列に実行される複数タスクの相互作用の中で起こりうる全ての状態を監視することが難しくなります。問題は非決定的に起こる可能性があり、デバッグをさらに難しくします。

並列プログラムの予測できない振る舞いを示す有名な例があります。1995年、NASAは火星にパスファインダーを送りました。お隣の赤い惑星への着陸成功からほどなくして、ミッションは[突然の終わりを迎えそうになりました](http://research.microsoft.com/en-us/um/people/mbj/Mars_Pathfinder/Mars_Pathfinder.html)。探査機が原因不明の再起動を続けたのです。優先順位の低いスレッドが優先順位の高いスレッドをブロックする「優先順位逆転」という現象でした。この問題については後ほど詳しく見ていきますが、この例から、たとえ膨大なリソースと有能なエンジニアがそろっている状況であっても、並行プログラミングが様々な形で牙を剥くことがあることがわかるでしょう。

### リソースの共有

多くの並行プログラミングに関する悪の根源は、複数スレッド間で共有されるリソースへのアクセスにあります。リソースにはプロパティやオブジェクト、より一般的にメモリ、ネットワークデバイス、ファイルなどがあります。複数スレッド間で共有するものは全てコンフリクトの原因になり得るため、このようなコンフリクトを防ぐための安全策を講じる必要があります。

問題をデモするために、カウンターとして使う整数型のプロパティというシンプルなリソースの例を見ていきましょう。並列に実行されるスレッドAとBがあり、両者が同時にカウンターをインクリメントするという状況を考えます。問題は、CやObjective-Cで書かれた１行のコードがたいていCPUへの命令としては１つではないことにあります。カウンターをインクリメントするためには、まず現在の値をメモリーから読み出し、その後値に1を加え、最後にメモリーに書き戻す必要があります。

両方のスレッドが同時にこれをやろうとしたときに生じうる危険を想像してください。例えば、スレッドAとスレッドBの両方がカウンターの値——ここでは17としましょう——をメモリに読み出し、スレッドAがカウンターを1増やして18をメモリに書き込んだとします。同時にスレッドBもカウンターを1増やして、スレッドAのすぐ後に18をメモリーに書き込んだとします。この時点でデータは壊れてしまいます。17から2回カウンターを増やしているのに値は18になってしまっているからです。

![Race condition](http://www.objc.io/images/issue-2/race-condition@2x.png)

この問題は[race condition](http://ja.wikipedia.org/wiki/競合状態)と呼ばれ、あるスレッドがリソースへアクセスする前に他のスレッドがリソースを使っていないか確認することなしに、複数スレッドでリソースを共有すると必ず発生します。単純な整数型ではなくより複雑な構造体を扱っている場合、メモリに書き込み中に他のスレッドが読みにきて、一部は新しくて、一部は古い、または初期化されていないデータになっているというようなことも起こりえます。これを防ぐためには、複数のスレッドは共有リソースに対し相互排他的にアクセスする必要があります。

実際には状況はさらに複雑です。なぜなら最近のCPUは最適化のためにメモリへの読み込み、書き込みの順序を変えるからです。（[out-of-oder execution](http://ja.wikipedia.org/wiki/アウト・オブ・オーダー実行)）

### 相互排他

相互排他的アクセスとは特定のリソースに対して同時にアクセスできるスレッドが１つだけという意味です。これを保証するために、リソースを利用したいスレッドはまずmutex lockを獲得する必要があります。作業が完了したらロックを解放し、他のスレッドがアクセスできるようにします。

![](http://www.objc.io/images/issue-2/locking@2x.png)

相互排他アクセスを保証するのに加え、ロックはout-of-order executionに起因する問題についても対処する必要があります。CPUがプログラムの命令通りの順序でメモリへのアクセスを行うことが保証できない場合、相互排他アクセスだけでは不十分です。このCPU最適化の副作用のワークアラウンドとして[メモリバリア](http://en.wikipedia.org/wiki/Memory_barrier)が使われます。メモリバリアを使うと、バリアを超えてout-of-order executionが起こらないことを保証できます。

もちろんmutex lockの実装そのものもrace conditionが起きないようにする必要があります。これは簡単な仕事ではなく、モダンなCPUに対する特別な命令を利用する必要があります。atomic operationについてはDanielの[low-level concurrency techniques](http://www.objc.io/issue-2/low-level-concurrency-apis.html)の記事が詳しいです。

Objective-Cのプロパティはatomicとして宣言することで、言語レベルのロックの仕組みが利用できます。実際プロパティはデフォルトでatomicになります。atomicとしてプロパティを宣言すると、プロパティにアクセスするたびにロックとロック解除が走ることになります。念のため全てのプロパティをatomicとして宣言しておきたくなるかもしれません。しかしロックにはコストが付いてきます。

リソースに対するロックの獲得には常にパフォーマンス上のコストがあります。ロックの獲得、解放はrace-condition freeである必要がありますが、マルチコアなシステムでこれは簡単ではありません。そしてロックを獲得するとき、スレッドは他のスレッドがロックを解放するのを待たなければならないかもしれません。この場合スレッドはスリープし、他のスレッドのロック解放の通知を受け取る必要があります。これらの作業はすべてコストが高く複雑です。

ロックにはいくつか種類があります。あるものは競合がない場合は非常に高速だが競合があると遅いというもので、またあるものは基本は高コストですが競合時のコストが比較的低いといった感じです。（ロックの競合とは既にロックされているものをさらに別のスレッドがロックしようとする状況のことです。）

ここにはトレードオフがあります。ロックの獲得と解放にはロックのオーバーヘッドと言うコストがかかります。従って[クリティカルセクション](http://ja.wikipedia.org/wiki/クリティカルセクション)に出たり入ったりを繰り返さないように気をつける必要があります。同時に、コードの中であまりにも多くの箇所でロック獲得を行うと、ロック獲得を待つためにスレッドの実行が止まるという、ロック競合のリスクがあります。これは解決が難しい問題です。

並行に実行させるつもりが、共有リソースのロックの仕方のせいで、実際には一度に１つのスレッドしかアクティブにならないようなコードを見かけることがよくあります。自分の書いたコードがマルチコア環境でどのようにスケジュールされるかを予測することはたいてい難しいです。Instrumentsの[CPU strategy view](http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html)を利用してCPUコアを効率よく利用しているかどうかを見ることができます。

### デッドロック

### Starvation

### 優先順位逆転

### まとめ
